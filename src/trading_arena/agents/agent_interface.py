"""
Agent Interface for Autonomous Trading Agents.

Defines the abstract interface that all trading agents must implement,
along with core data structures for market data, positions, and signals.
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Optional
from dataclasses import dataclass
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


@dataclass
class MarketData:
    """
    Market data snapshot for a trading symbol.

    Contains OHLCV data along with optional funding rate information
    for perpetual futures contracts.
    """
    symbol: str
    timestamp: datetime
    open_price: float
    high_price: float
    low_price: float
    close_price: float
    volume: float
    funding_rate: Optional[float] = None


@dataclass
class Position:
    """
    Current trading position information.

    Represents an open position with all relevant pricing and P&L data.
    """
    symbol: str
    side: str  # LONG, SHORT
    size: float
    entry_price: float
    mark_price: float
    unrealized_pnl: float
    percentage_pnl: float


@dataclass
class TradingSignal:
    """
    Trading signal generated by an agent.

    Contains all information needed to execute a trading decision,
    including optional risk management parameters.
    """
    symbol: str
    action: str  # BUY, SELL, HOLD
    quantity: Optional[float] = None
    leverage: Optional[int] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    confidence: Optional[float] = None
    reasoning: Optional[str] = None


class AgentInterface(ABC):
    """
    Abstract base class for all trading agents.

    Defines the interface that agents must implement to participate
    in the autonomous trading arena. Agents are responsible for:

    1. Market analysis and signal generation
    2. Order execution feedback handling
    3. Risk management and position monitoring
    4. Decision logging and audit trails

    Agents operate autonomously without human intervention,
    making all trading decisions based on market data and
    their internal strategies.
    """

    def __init__(self, agent_id: int, config: Dict):
        """
        Initialize the trading agent.

        Args:
            agent_id: Unique identifier for this agent instance
            config: Agent configuration dictionary containing:
                - risk_profile: Risk tolerance level (conservative, moderate, aggressive)
                - max_leverage: Maximum allowed leverage
                - max_drawdown: Maximum allowed drawdown
                - Other strategy-specific parameters
        """
        self.agent_id = agent_id
        self.config = config
        self.positions = {}  # Current positions by symbol
        self.last_signals = {}  # Last generated signals by symbol
        self.logger = logging.getLogger(f"agent.{agent_id}")

    @abstractmethod
    async def analyze_market(self, market_data: List[MarketData]) -> Dict[str, TradingSignal]:
        """
        Analyze market data and generate trading decisions.

        This is the core method where agents implement their trading strategies.
        Agents should analyze the provided market data and return trading signals
        for each symbol they want to trade.

        Args:
            market_data: List of MarketData objects for tracked symbols

        Returns:
            Dictionary mapping symbol names to TradingSignal objects.
            Only symbols with actionable signals should be included.

        Example:
            return {
                "BTCUSDT": TradingSignal(
                    symbol="BTCUSDT",
                    action="BUY",
                    quantity=0.1,
                    leverage=5,
                    reasoning="Bullish momentum detected"
                )
            }
        """
        pass

    @abstractmethod
    async def handle_fill(self, fill_info: Dict):
        """
        Handle order execution feedback from the exchange.

        Called when an order placed by this agent is filled.
        Agents should update their internal state based on the fill information.

        Args:
            fill_info: Dictionary containing order fill details:
                - orderId: Exchange order ID
                - symbol: Trading symbol
                - side: Order side (BUY/SELL)
                - executedQty: Filled quantity
                - avgPrice: Average fill price
                - commission: Trading fees
                - status: Order status

        Example:
            await self.handle_fill({
                "orderId": "12345",
                "symbol": "BTCUSDT",
                "side": "BUY",
                "executedQty": "0.100",
                "avgPrice": "50500.00",
                "commission": "0.50500000",
                "status": "FILLED"
            })
        """
        pass

    @abstractmethod
    async def manage_risk(self, positions: List[Position]) -> List[TradingSignal]:
        """
        Generate risk management signals for existing positions.

        Called periodically to allow agents to manage risk on open positions.
        Agents should generate signals to close positions, adjust stops, or
        take profits based on their risk management strategy.

        Args:
            positions: List of current open positions

        Returns:
            List of TradingSignal objects for risk management actions.
            Return empty list if no risk actions are needed.

        Example:
            return [
                TradingSignal(
                    symbol="BTCUSDT",
                    action="SELL",
                    quantity=0.1,  # Close entire position
                    reasoning="Stop loss triggered"
                )
            ]
        """
        pass

    @abstractmethod
    async def log_decision(self, signal: TradingSignal, context: Dict):
        """
        Log trading decisions for audit trail and analysis.

        Called for every trading signal to maintain a comprehensive audit trail.
        Agents should log the reasoning behind their decisions for later analysis.

        Args:
            signal: The trading signal being logged
            context: Additional context information:
                - market_data: Current market conditions
                - positions: Current position state
                - account_balance: Available capital
                - timestamp: Decision timestamp

        Example:
            await self.log_decision(
                signal=buy_signal,
                context={
                    "market_data": market_snapshot,
                    "rsi": 75.5,
                    "volume_profile": "increasing"
                }
            )
        """
        pass

    def update_position(self, symbol: str, position_info: Dict):
        """
        Update internal position state.

        Helper method to maintain current position information.
        Called by the runtime when position changes occur.

        Args:
            symbol: Trading symbol
            position_info: Position information dictionary
        """
        self.positions[symbol] = position_info
        self.logger.debug(f"Updated position for {symbol}: {position_info}")

    def get_position(self, symbol: str) -> Optional[Dict]:
        """
        Get current position information for a symbol.

        Args:
            symbol: Trading symbol

        Returns:
            Position information dictionary or None if no position
        """
        return self.positions.get(symbol)

    def is_long(self, symbol: str) -> bool:
        """
        Check if agent has a long position in symbol.

        Args:
            symbol: Trading symbol

        Returns:
            True if long position exists, False otherwise
        """
        pos = self.get_position(symbol)
        return pos and float(pos.get('size', 0)) > 0

    def is_short(self, symbol: str) -> bool:
        """
        Check if agent has a short position in symbol.

        Args:
            symbol: Trading symbol

        Returns:
            True if short position exists, False otherwise
        """
        pos = self.get_position(symbol)
        return pos and float(pos.get('size', 0)) < 0

    def is_flat(self, symbol: str) -> bool:
        """
        Check if agent has no position in symbol.

        Args:
            symbol: Trading symbol

        Returns:
            True if no position exists, False otherwise
        """
        return not self.is_long(symbol) and not self.is_short(symbol)